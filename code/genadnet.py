# Thanks to Dr. Sreeni 
# DMD/GAN/Colab/GenAdNet

import os
import numpy as np
from PIL import Image
from numpy import ones
from numpy import zeros
from numpy.random import randn
from keras.layers import Dense
from keras.layers import Conv2D
from keras.layers import Reshape
from keras.layers import Flatten
from numpy.random import randint
from keras.layers import Dropout
from keras.optimizers import Adam
from keras.layers import LeakyReLU
from keras.models import Sequential
from matplotlib import pyplot as plt
from keras.layers import Conv2DTranspose
from keras.datasets.cifar10 import load_data
from keras.models import load_model


SHmodel = load_model("/Model[NEW]big_Grayscale_img_vgg.pickle")

# To import pickle files
import pickle
folders = ['Lollipop', 'Kelihos_ver3', 'Gatak', 'Kelihos_ver1', 'Obfuscator.ACY', 'Simda', 'Tracur', 'Vundo', 'Ramnit']


# path to one family
data = os.path.join("/grayscale/Gatak")
images = []
for file_ in os.listdir(data):
  img_path = os.path.join(data, file_)
  with Image.open(img_path) as img:
    img = img.resize((224,224))
    img_array = np.array(img)
    img_array = img_array[:, :, :3]
    images.append(img_array)

# Convert list of images to array
X_train = np.array(images)
X_train.shape

# plot 25 images
from matplotlib import pyplot as plt
for i in range(25):
	plt.subplot(5, 5, 1 + i)
	plt.axis('off')
	plt.imshow(X_train[i])
plt.show()

# define the standalone discriminator model
#Given an input image, the Discriminator outputs the likelihood of the image being real.
#Binary classification - true or false (1 or 0). So using sigmoid activation.
def define_discriminator(in_shape=(224,224,3)):
	model = Sequential()

	model.add(Conv2D(128, (3,3), strides=(2,2), padding='same', input_shape=in_shape)) #16x16x128
	model.add(LeakyReLU(alpha=0.2))

	model.add(Conv2D(128, (3,3), strides=(2,2), padding='same')) #8x8x128
	model.add(LeakyReLU(alpha=0.2))

	model.add(Flatten()) #shape of 8192
	model.add(Dropout(0.4))
	model.add(Dense(1, activation='sigmoid')) #shape of 1
	# compile model
	opt = Adam(learning_rate=0.0002, beta_1=0.5)
	model.compile(loss='binary_crossentropy', optimizer=opt, metrics=['accuracy'])
	return model

test_discr = define_discriminator()
print(test_discr.summary())

from keras.models import Sequential
from keras.layers import Dense, Reshape, LeakyReLU, Conv2DTranspose, Conv2D, BatchNormalization

def define_generator(latent_dim):
    model = Sequential()

    # Initial dense layer
    n_nodes = 256 * 7 * 7  # 4096 nodes
    model.add(Dense(n_nodes, input_dim=latent_dim))
    model.add(LeakyReLU(alpha=0.2))
    model.add(Reshape((7, 7, 256)))  # Reshape to 4x4x256

    # Upsampling blocks
    model.add(Conv2DTranspose(256, (4, 4), strides=(2, 2), padding='same'))
    model.add(LeakyReLU(alpha=0.2))
    model.add(BatchNormalization())

    model.add(Conv2DTranspose(128, (4, 4), strides=(2, 2), padding='same'))
    model.add(LeakyReLU(alpha=0.2))
    model.add(BatchNormalization())

    model.add(Conv2DTranspose(64, (4, 4), strides=(2, 2), padding='same'))
    model.add(LeakyReLU(alpha=0.2))
    model.add(BatchNormalization())

    model.add(Conv2DTranspose(32, (4, 4), strides=(2, 2), padding='same'))
    model.add(LeakyReLU(alpha=0.2))
    model.add(BatchNormalization())

    model.add(Conv2DTranspose(32, (4, 4), strides=(2, 2), padding='same'))
    model.add(LeakyReLU(alpha=0.2))
    model.add(BatchNormalization())

    # Output layer
    model.add(Conv2D(3, (3, 3), activation='tanh', padding='same'))  # Output shape: 32x32x3

    return model

test_gen = define_generator(100)
print(test_gen.summary())

# Define the combined generator and discriminator model, for updating the generator
# Discriminator is trained separately so here only generator will be trained by keeping
# the discriminator constant.

def define_gan(generator, discriminator):

  # Discriminator is trained separately. So set to not trainable.
  discriminator.trainable = False

  # Connect generator and discriminator
  model = Sequential()
  model.add(generator)
  model.add(discriminator)

  # compile model
  opt = Adam(learning_rate=0.0002, beta_1=0.5)
  model.compile(loss='binary_crossentropy', optimizer=opt)

  return model

# load cifar training images
def load_real_samples():

  trainX = X_train

  # cConvert to float and scale.
  X = trainX.astype('float32')

  # scale from [0,255] to [-1,1]
  X = (X - 127.5) / 127.5
  #Generator uses tanh activation so rescale
  #original images to -1 to 1 to match the output of generator.
  return X

# Pick a batch of random real samples to train the GAN
# In fact, we will train the GAN on a half batch of real images and another
# half batch of fake images.
# For each real image we assign a label 1 and for fake we assign label 0.

def generate_real_samples(dataset, n_samples):

  # Choose random images
	ix = randint(0, dataset.shape[0], n_samples)

  # Select the random images and assign it to X
	X = dataset[ix]

  # Generate class labels and assign to y
  # Label=1 indicating they are real
	y = ones((n_samples, 1))
	return X, y

# Generate n_samples number of latent vectors as input for the generator

def generate_latent_points(latent_dim, n_samples):

  # generate points in the latent space
	x_input = randn(latent_dim * n_samples)

  # reshape into a batch of inputs for the network
	x_input = x_input.reshape(n_samples, latent_dim)
	return x_input

"""##**generate_fake_samples**"""

# Use the generator to generate n fake examples, with class labels
# Supply the generator, latent_dim and number of samples as input.
# Use the above latent point generator to generate latent points.

def generate_fake_samples(generator, latent_dim, n_samples):

  # generate points in latent space
	x_input = generate_latent_points(latent_dim, n_samples)

  # predict using generator to generate fake samples.
	X = generator.predict(x_input)

  # Class labels will be 0 as these samples are fake.
	y = zeros((n_samples, 1))  #Label=0 indicating they are fake
	return X, y

"""##**Train Function**"""

# Train the generator and discriminator
# We loop through a number of epochs to train our Discriminator by first selecting
# a random batch of images fromv our true/real dataset.
# Then, generating a set of images using the generator.
# Feed both set of images into the Discriminator.
# Finally, set the loss parameters for both the real and fake images, as well as the combined loss.
Gen_Loss = []
def train(g_model, d_model, gan_model, dataset, latent_dim, n_epochs=100, n_batch=10):

  #the discriminator model is updated for a half batch of real samples
  # and a half batch of fake samples, combined a single batch.
  bat_per_epo = int(dataset.shape[0] / n_batch)
  half_batch = int(n_batch / 2)

  # manually enumerate epochs and bacthes.
  for i in range(n_epochs):

    # enumerate batches over the training set
    for j in range(bat_per_epo):

      # Train the discriminator on real and fake images, separately (half batch each)
      # Research showed that separate training is more effective.
			# get randomly selected 'real' samples
      X_real, y_real = generate_real_samples(dataset, half_batch)

      # Update discriminator model weights
      # Train_on_batch allows you to update weights based on a collection
      # of samples you provide
      # Let us just capture loss and ignore accuracy value (2nd output below)
      d_loss_real, _ = d_model.train_on_batch(X_real, y_real)

      # Generate 'fake' examples
      X_fake, y_fake = generate_fake_samples(g_model, latent_dim, half_batch)

      # Update discriminator model weights
      d_loss_fake, _ = d_model.train_on_batch(X_fake, y_fake)

      # d_loss = 0.5 * np.add(d_loss_real, d_loss_fake) #Average loss if you want to report single..

			# Prepare points in latent space as input for the generator
      X_gan = generate_latent_points(latent_dim, n_batch)
      #print(X_gan.shape)

      # The generator wants the discriminator to label the generated samples
      # as valid (ones)
      # This is where the generator is trying to trick discriminator into believing
      # the generated image is true (hence value of 1 for y)
      y_gan = ones((n_batch, 1))

      # Generator is part of combined model where it got directly linked with the discriminator
      # Train the generator with latent_dim as x and 1 as y.
      # Again, 1 as the output as it is adversarial and if generator did a great
      # job of folling the discriminator then the output would be 1 (true)
			# update the generator via the discriminator's error
      g_loss = gan_model.train_on_batch(X_gan, y_gan)

      # Print losses on this batch
      print('Epoch>%d, Batch %d/%d, d1=%.3f, d2=%.3f g=%.3f' %
       (i+1, j+1, bat_per_epo, d_loss_real, d_loss_fake, g_loss))

      if i % 50 == 0:
            prediction_model(i)
      #Gen_Loss.append(g_loss)


  # save the generator model
  g_model.save('/GAN[GS_Gatak]_generator.pickle')

SHmodel.summary()

from sklearn import preprocessing
le = preprocessing.LabelEncoder()

correctly_predicted = []

folders = ['Gatak', 'Kelihos_ver1', 'Kelihos_ver3', 'Lollipop', 'Obfuscator.ACY', 'Ramnit', 'Simda', 'Tracur', 'Vundo']
def prediction_model(epoch):
    r, c = 5, 5
    noise = np.random.normal(0, 1, (r * c, 100))
    gen_imgs = generator.predict(noise)

    # Rescale images 0 - 1
    gen_imgs = 0.5 * gen_imgs + 0.5
    print(gen_imgs.shape)

    prediction = SHmodel.predict(gen_imgs)
    count = 0
    for i in range(25):
        predicted_class_index = prediction[i].argmax()
        predicted_class_label = folders[predicted_class_index]

        if predicted_class_label != "Obfuscator.ACY":
          # Create and save the image
          plt.figure(figsize=(gen_imgs[i].shape[1] / 100, gen_imgs[i].shape[0] / 100), dpi=100)
          plt.imshow(gen_imgs[i])  # Display as grayscale
          plt.axis('off')  # Remove axes
          plt.savefig(f"/GeneratedGrayscale/Gatak/GS_Gatak_{epoch}.png", bbox_inches='tight', pad_inches=0)
          plt.close()
          print("Saved Image")
        else:
          count += 1
          continue
    #correctly_predicted.append(count) # stores the number of correctly predicted samples. which could be used to draw a graph

for ele in correctly_predicted:
  if ele == 1 :
    print(ele)

correctly_predicted

"""##**Train the GAN**"""

# size of the latent space
latent_dim = 100

# create the discriminator
discriminator = define_discriminator()

# create the generator
generator = define_generator(latent_dim)

# create the gan
gan_model = define_gan(generator, discriminator)

# load image data
dataset = load_real_samples()

# train model
train(generator, discriminator, gan_model, dataset, latent_dim, n_epochs = 800)

dataset.shape

generator = load_model('/cifar[EG_Gatak]_generator_epochs.pickle')

noise = np.random.normal(0, 1, (1 * 1, 100))
gen_imgs = generator.predict(noise)

def show_img(img):
  plt.imshow(img[0])
  plt.axis('off')
  plt.show()

show_img(gen_imgs)

import matplotlib.pyplot as plt

# Create a figure with adjusted size
plt.figure(figsize=(gen_imgs[i].shape[1] / 100, gen_imgs[i].shape[0] / 100), dpi=100)

# Plot the image without padding
plt.imshow(gen_imgs[i])
plt.axis('off')

# Save the image without extra white space
plt.savefig(f"/Sh_Gatak_Sample.png", bbox_inches='tight', pad_inches=0)

# Close the plot
plt.close()

prediction = SHmodel.predict(gen_imgs)

predicted_class_index = prediction.argmax()
predicted_class_label = folders[predicted_class_index]
print(predicted_class_label)

import matplotlib.pyplot as plt

# Assuming Gen_Loss is your list of generator loss values
# Downsample the data by taking every nth element
n = 10  # Change this value based on your preference for downsampling
downsampled_loss = Gen_Loss[::n]

# Create a line plot with downsampled data
plt.plot(range(0, len(Gen_Loss), n), downsampled_loss)

# Add labels and title
plt.xlabel('Iteration')
plt.ylabel('Accuracy')
plt.title('Accuracy Trend')

# Show the plot
plt.show()

# Now, let us load the generator model and generate images

from keras.models import load_model
from numpy.random import randn

# Plot generated images
def show_plot(examples, n):
	for i in range(n * n):
		plt.subplot(n, n, 1 + i)
		plt.axis('off')
		plt.imshow(examples[i, :, :, :])
	plt.show()

# load model
model = load_model('/cifar128_generator_2epochs.h5') #Model trained for 100 epochs

# generate images
latent_points = generate_latent_points(100, 25)  #Latent dim and n_samples

# generate images
X = model.predict(latent_points)
# scale from [-1,1] to [0,1]
X = (X + 1) / 2.0

import numpy as np
X = (X*255).astype(np.uint8)

# plot the result
show_plot(X, 5)

