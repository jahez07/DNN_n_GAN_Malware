# DMD/GAN/Colab

# Importing necessary packages
from PIL import Image
import numpy as np
import matplotlib.pyplot as plt
import os
import pandas as pd
from keras.models import load_model

Model = load_model("/Model[NEW]big_Grayscale_img_vgg.h5")
Model.summary()

folders = ['Gatak', 'Kelihos_ver1', 'Kelihos_ver3', 'Lollipop', 'Obfuscator.ACY', 'Ramnit', 'Simda', 'Tracur', 'Vundo']
# path to one family
data = os.path.join("/Grayscale/Ramnit")
images = []
for file_ in os.listdir(data):
  img_path = os.path.join(data, file_)
  with Image.open(img_path) as img:
    img = img.resize((224,224))
    img_array = np.array(img)
    img_array = img_array[:, :, :3]
    images.append(img_array)

# Convert list of images to array
X_train = np.array(images)

predictions = Model.predict(X_train)

count = 0
selected_images = []
#selected_labels = []
path = "/SelectedData/Grayscale"
for i in range(len(predictions)):
    pred_class_index = predictions[i].argmax()
    pred_class_label = folders[pred_class_index]
    #print(pred_class_label)
    if pred_class_label == "Ramnit":
      class_ = "Ramnit"
      img = Image.fromarray(X_train[i])
      img.save(f"{path}/{class_}/Orginial({class_})_{i}.png")
      selected_images.append(X_train[i])
      count += 1
print(count)

len(selected_images)

import pickle
data_dict = {}
folder = "Ramnit"
output_file = f"/SelectedData/Grayscale/{folder}.pickle"
data_dict[folder] = selected_images

with open(output_file, 'wb') as f:
    pickle.dump(data_dict, f)

selected_images = np.array(selected_images)

selected_images.shape

img_size = (224, 224)

last_conv_layer_name = 'conv1d_1'

import tensorflow as tf
from tensorflow import keras

def make_gradcam_heatmap(img_array, model, last_conv_layer_name, pred_index=None):
    # Creating a model that maps the input image to the activations
    # of the last conv layer as well as the output predictions
    grad_model = keras.models.Model(
        model.inputs, [model.get_layer(last_conv_layer_name).output, model.output]
    )

    # Compute the gradient of the top predicted class for our input image
    # with respect to the activations of the last conv layer
    with tf.GradientTape() as tape:
        last_conv_layer_output, preds = grad_model(img_array)
        if pred_index is None:
            pred_index = tf.argmax(preds[0])
        class_channel = preds[:, pred_index]

    # This is the gradient of the output neuron (top predicted or chosen)
    # with regard to the output feature map of the last conv layer
    grads = tape.gradient(class_channel, last_conv_layer_output)

    # Element-wise multiplication of the gradients and last_conv_layer_output
    guided_grads = grads[0] * last_conv_layer_output[0]

    # Summing over the last dimension (channels)
    heatmap = tf.reduce_sum(guided_grads, axis=-1)

    # For visualization purposes, normalize the heatmap between 0 and 1
    heatmap = tf.maximum(heatmap, 0) / tf.reduce_max(heatmap)

    return heatmap.numpy()

CUM_CAM = np.zeros((7, 3))
print(CUM_CAM)

from tensorflow.keras.preprocessing import image
for i in range(len(selected_images)):
    img_array = selected_images[i]
    img_array = image.img_to_array(img_array)
    img_array = np.expand_dims(img_array, axis=0)

    heatmap = make_gradcam_heatmap(img_array, Model, last_conv_layer_name)

    for a in range(7):
      for b in range(3):
        CUM_CAM[a][b] += heatmap[a][b]

img_array = selected_images[60]
img_array = image.img_to_array(img_array)
img_array = np.expand_dims(img_array, axis=0)

heatmap = make_gradcam_heatmap(img_array, Model, last_conv_layer_name)

# Display heatmap
plt.matshow(heatmap)
plt.gca().set_aspect('0.7', adjustable='box')
plt.axis('off')
plt.show()

